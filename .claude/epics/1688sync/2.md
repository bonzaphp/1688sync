---
name: "存储系统"
status: "open"
created: "2025-11-18T13:09:28Z"
updated: 
github: https://github.com/bonzaphp/1688sync/issues/2
depends_on: []
parallel: false
conflicts_with: ""
---

# 任务: 存储系统

## Overview

构建1688sync项目的存储系统，作为整个项目的基础设施，为数据抓取、处理、调度模块提供统一的存储服务。系统需要支持高并发数据写入、灵活的数据结构管理、图片文件存储，以及完善的数据一致性保障机制。

## Acceptance Criteria

### 核心功能要求
- [ ] **数据库设计完成**
  - 设计商品表结构，包含商品ID、标题、价格、图片、规格等字段
  - 设计供应商表结构，包含供应商ID、名称、联系方式、评级等
  - 设计图片表结构，支持主图和详情图存储
  - 设计同步日志表，记录同步状态、错误信息等

- [ ] **ORM和数据模型**
  - 实现商品数据模型（Product）
  - 实现供应商数据模型（Supplier）
  - 实现图片数据模型（Image）
  - 实现同步记录数据模型（SyncRecord）
  - 支持数据验证和字段类型检查

- [ ] **数据库连接管理**
  - 实现连接池管理，支持高并发访问
  - 配置数据库连接参数（超时、重试等）
  - 实现连接健康检查和自动重连
  - 支持数据库事务管理

- [ ] **CRUD操作接口**
  - 实现商品数据的增删改查
  - 实现批量插入和批量更新操作
  - 实现图片文件的上传和管理
  - 实现数据去重逻辑（基于商品ID）

- [ ] **数据一致性保障**
  - 实现数据完整性约束
  - 配置外键关系和级联操作
  - 实现数据校验规则
  - 支持软删除和历史版本管理

### 技术实现要求
- [ ] **数据库选择和配置**
  - 选择PostgreSQL作为主数据库（支持JSON字段）
  - 配置数据库索引优化查询性能
  - 设置数据库备份和恢复策略
  - 配置数据库监控和日志

- [ ] **图片存储系统**
  - 实现本地文件系统存储图片
  - 支持图片的压缩和格式转换
  - 实现图片缓存机制
  - 配置图片URL生成和管理

- [ ] **性能优化**
  - 实现数据库查询优化
  - 配置连接池大小和超时参数
  - 实现批量操作减少I/O次数
  - 配置适当的缓存策略

- [ ] **测试覆盖**
  - 编写数据库连接和操作测试
  - 实现CRUD操作的单元测试
  - 编写并发写入压力测试
  - 实现数据一致性测试用例

## Technical Details

### 系统架构设计
```
存储系统架构:
┌─────────────────┐
│   API接口层     │ ← 统一的CRUD接口
├─────────────────┤
│   数据模型层    │ ← ORM模型定义
├─────────────────┤
│   连接管理层    │ ← 连接池、事务管理
├─────────────────┤
│   数据库层      │ ← PostgreSQL + 索引
└─────────────────┘
```

### 数据模型设计

#### 商品表 (products)
```sql
- id: BIGINT PRIMARY KEY (商品唯一标识)
- source_id: VARCHAR(50) UNIQUE NOT NULL (1688原始ID)
- title: VARCHAR(500) NOT NULL (商品标题)
- subtitle: VARCHAR(500) (商品副标题)
- price_min: DECIMAL(10,2) (最低价格)
- price_max: DECIMAL(10,2) (最高价格)
- currency: VARCHAR(3) DEFAULT 'CNY' (货币单位)
- moq: INTEGER (最小起订量)
- main_image_url: VARCHAR(1000) (主图片URL)
- detail_images: JSON (详情图片列表)
- specifications: JSON (商品规格参数)
- supplier_id: BIGINT (供应商ID，外键)
- sales_count: INTEGER (销量)
- rating: DECIMAL(3,2) (评分)
- created_at: TIMESTAMP (创建时间)
- updated_at: TIMESTAMP (更新时间)
- sync_status: VARCHAR(20) DEFAULT 'pending' (同步状态)
```

#### 供应商表 (suppliers)
```sql
- id: BIGINT PRIMARY KEY (供应商唯一标识)
- source_id: VARCHAR(50) UNIQUE NOT NULL (1688原始ID)
- name: VARCHAR(200) NOT NULL (供应商名称)
- company_name: VARCHAR(200) (公司名称)
- contact_info: JSON (联系信息)
- location: VARCHAR(100) (地址)
- rating: DECIMAL(3,2) (评分)
- product_count: INTEGER (商品数量)
- created_at: TIMESTAMP (创建时间)
- updated_at: TIMESTAMP (更新时间)
```

#### 图片表 (images)
```sql
- id: BIGINT PRIMARY KEY (图片唯一标识)
- product_id: BIGINT NOT NULL (商品ID，外键)
- url: VARCHAR(1000) NOT NULL (原始URL)
- local_path: VARCHAR(1000) (本地存储路径)
- image_type: VARCHAR(20) (图片类型：main/detail)
- width: INTEGER (宽度)
- height: INTEGER (高度)
- size: INTEGER (文件大小字节)
- created_at: TIMESTAMP (创建时间)
```

#### 同步记录表 (sync_records)
```sql
- id: BIGINT PRIMARY KEY (记录唯一标识)
- task_id: VARCHAR(100) (任务ID)
- operation_type: VARCHAR(20) (操作类型：full/incremental)
- status: VARCHAR(20) (状态：running/completed/failed)
- start_time: TIMESTAMP (开始时间)
- end_time: TIMESTAMP (结束时间)
- total_count: INTEGER (总数量)
- success_count: INTEGER (成功数量)
- error_count: INTEGER (失败数量)
- error_details: JSON (错误详情)
```

### 技术栈选择
- **数据库**: PostgreSQL 14+
- **ORM框架**: SQLAlchemy 2.0+
- **数据库连接**: asyncpg (异步驱动)
- **迁移工具**: Alembic
- **图片处理**: Pillow
- **缓存**: Redis (可选)

### 关键实现细节

#### 1. 数据库连接池配置
```python
# 连接池参数
engine = create_async_engine(
    DATABASE_URL,
    pool_size=20,          # 基础连接数
    max_overflow=30,       # 最大溢出连接
    pool_pre_ping=True,    # 连接预检
    pool_recycle=3600,     # 连接回收时间
)
```

#### 2. 数据模型定义示例
```python
from sqlalchemy.orm import declarative_base
from sqlalchemy import Column, Integer, String, DateTime, Numeric, JSON

Base = declarative_base()

class Product(Base):
    __tablename__ = "products"

    id = Column(BigInteger, primary_key=True)
    source_id = Column(String(50), unique=True, nullable=False)
    title = Column(String(500), nullable=False)
    price_min = Column(Numeric(10, 2))
    specifications = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
```

#### 3. 批量操作实现
```python
async def batch_insert_products(products: List[ProductData]):
    """批量插入商品数据，提升性能"""
    async with async_session() as session:
        # 使用 PostgreSQL 的 ON CONFLICT DO UPDATE
        stmt = insert(Product).values(products_data)
        await session.execute(stmt)
        await session.commit()
```

#### 4. 图片存储管理
```python
async def save_image_locally(image_url: str, product_id: int) -> str:
    """下载并保存图片到本地文件系统"""
    # 生成文件名和路径
    image_hash = hashlib.md5(image_url.encode()).hexdigest()
    file_path = f"images/{product_id}/{image_hash}.jpg"

    # 下载图片
    async with aiohttp.ClientSession() as session:
        async with session.get(image_url) as resp:
            if resp.status == 200:
                # 压缩和格式转换
                image_data = await resp.read()
                processed_image = compress_image(image_data)
                # 保存到本地
                async with aiofiles.open(file_path, 'wb') as f:
                    await f.write(processed_image)

    return file_path
```

### 性能和扩展性考虑
- **索引优化**: 对经常查询的字段（source_id, supplier_id, sync_status）建立索引
- **分页查询**: 实现大数据量的分页查询接口
- **连接池管理**: 根据并发需求调整连接池大小
- **缓存策略**: 对热点数据进行Redis缓存

## Effort Estimate

### 工作量评估
- **开发时间**: 15-20个工作日
- **任务分解**:
  - 数据库设计和建表: 2天
  - ORM模型和基础CRUD: 5天
  - 连接池和事务管理: 3天
  - 图片存储系统: 4天
  - 性能优化和测试: 3-4天
  - 文档和代码评审: 2天

### 技能要求
- **必备技能**:
  - SQL和数据库设计经验
  - SQLAlchemy/ORM框架使用
  - PostgreSQL数据库管理
  - Python异步编程

- **推荐技能**:
  - Redis缓存使用经验
  - 数据库性能优化
  - 图片处理技术

### 风险评估
- **高风险**: 大并发写入时的性能瓶颈
- **中风险**: 数据一致性和事务管理复杂性
- **低风险**: 图片存储空间和管理

## Dependencies

### 内部依赖
- 无（作为基础设施任务最先完成）

### 外部依赖
- PostgreSQL数据库环境
- 存储空间（建议至少100GB用于图片存储）

## Quality Gates

- [ ] **代码质量**: 通过Code Review，代码覆盖率≥80%
- [ ] **性能测试**: 支持100并发连接，响应时间<100ms
- [ ] **数据完整性**: 通过数据一致性测试，无数据丢失
- [ ] **文档完整性**: API文档和部署文档完整

## Deliverables

1. **数据库设计和建表脚本**
2. **存储系统API接口文档**
3. **ORM模型和CRUD操作代码**
4. **测试用例和测试报告**
5. **部署和配置文档**
